// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT IT DIRECTLY
import { ExecutionResult, Sink } from "graphql-ws";

import {
  OnBarsUpdatedSubscription,
  OnBarsUpdatedSubscriptionVariables,
  OnDetailedStatsUpdatedSubscription,
  OnDetailedStatsUpdatedSubscriptionVariables,
  OnEventLabelCreatedSubscription,
  OnEventLabelCreatedSubscriptionVariables,
  OnEventsCreatedSubscription,
  OnEventsCreatedSubscriptionVariables,
  OnLatestPairUpdatedSubscription,
  OnLatestPairUpdatedSubscriptionVariables,
  OnLatestTokensSubscription,
  OnLatestTokensSubscriptionVariables,
  OnNftAssetsCreatedSubscription,
  OnNftAssetsCreatedSubscriptionVariables,
  OnNftEventsCreatedSubscription,
  OnNftEventsCreatedSubscriptionVariables,
  OnNftPoolEventsCreatedSubscription,
  OnNftPoolEventsCreatedSubscriptionVariables,
  OnPairMetadataUpdatedSubscription,
  OnPairMetadataUpdatedSubscriptionVariables,
  OnPriceUpdatedSubscription,
  OnPriceUpdatedSubscriptionVariables,
  OnSimulateTokenContractSubscription,
  OnSimulateTokenContractSubscriptionVariables,
  OnTokenEventsCreatedSubscription,
  OnTokenEventsCreatedSubscriptionVariables,
  OnTokenLifecycleEventsCreatedSubscription,
  OnTokenLifecycleEventsCreatedSubscriptionVariables,
} from "./generated/graphql";
import { Codex } from "./index";

export class Subscribe {
  constructor(private sdk: Codex) {}
  onBarsUpdated = async (
    vars: OnBarsUpdatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnBarsUpdatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnBarsUpdated($pairId: String, $quoteToken: QuoteToken, $statsType: TokenPairStatisticsType) {
  onBarsUpdated (pairId: $pairId, quoteToken: $quoteToken, statsType: $statsType) {
    aggregates { r1 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r1D { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r1S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r5 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r5S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r7D { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r15 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r15S { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r30 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r60 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r240 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } }, r720 { t, token { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken }, usd { buyVolume, buyers, buys, c, h, l, liquidity, o, sellVolume, sellers, sells, t, traders, transactions, v, volume, volumeNativeToken } } }, eventSortKey, networkId, pairAddress, pairId, quoteToken, statsType, timestamp
  }
}`,
      vars,
      sink,
    );
  onLatestTokens = async (
    vars: OnLatestTokensSubscriptionVariables,
    sink: Sink<ExecutionResult<OnLatestTokensSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnLatestTokens($id: String, $networkId: Int, $tokenAddress: String) {
  onLatestTokens (id: $id, networkId: $networkId, tokenAddress: $tokenAddress) {
    blockHash, blockNumber, creatorAddress, creatorBalance, decimals, id, networkId, simulationResults { buyGasUsed, buySuccess, buyTax, canRenounceOwnership, canTransferOwnership, isOwnerRenounced, maxBuyAmount, maxSellAmount, openTradingCall, sellGasUsed, sellSuccess, sellTax }, timeCreated, tokenAddress, tokenName, tokenSymbol, totalSupply, traceIndex, transactionHash, transactionIndex
  }
}`,
      vars,
      sink,
    );
  onDetailedStatsUpdated = async (
    vars: OnDetailedStatsUpdatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnDetailedStatsUpdatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnDetailedStatsUpdated($pairId: String, $statsType: TokenPairStatisticsType, $tokenOfInterest: TokenOfInterest) {
  onDetailedStatsUpdated (pairId: $pairId, statsType: $statsType, tokenOfInterest: $tokenOfInterest) {
    bucketCount, pairId, queryTimestamp, statsType, stats_day1 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_hour1 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_hour4 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_hour12 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, stats_min5 { buckets { end, start }, buyVolume { buckets, change, currentValue, previousValue }, buyers { buckets, change, currentValue, previousValue }, buys { buckets, change, currentValue, previousValue }, endTimestamp, sellVolume { buckets, change, currentValue, previousValue }, sellers { buckets, change, currentValue, previousValue }, sells { buckets, change, currentValue, previousValue }, timestamp, traders { buckets, change, currentValue, previousValue }, transactions { buckets, change, currentValue, previousValue }, volume { buckets, change, currentValue, previousValue }, windowSize }, tokenOfInterest
  }
}`,
      vars,
      sink,
    );
  onSimulateTokenContract = async (
    vars: OnSimulateTokenContractSubscriptionVariables,
    sink: Sink<ExecutionResult<OnSimulateTokenContractSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnSimulateTokenContract($contractAddress: String, $networkId: Int!, $simulationId: String) {
  onSimulateTokenContract (contractAddress: $contractAddress, networkId: $networkId, simulationId: $simulationId) {
    analysisType, blockNumber, contractBalance { tokenContractEthBalance, tokenContractTokenBalance }, contractHashKey, creator { creatorAddress, creatorEthBalance, creatorTokenBalance }, deploy { deploySuccess, tokenMintedToDeployer }, errors { contractBalanceErrors { tokenContractEthBalanceError, tokenContractTokenBalanceError }, creatorErrors { creatorEthBalanceError, creatorTokenBalanceError }, deployErrors { deployError, tokenMintedToDeployerError }, liquidityErrors { addLiquidityError, lpTotalSupplyError, postLiquidityEnableTradingError, preLiquidityEnableTradingError }, ownerErrors { ownerAddressError, ownerEthBalanceError, ownerTokenBalanceError }, simulatorError, swapErrors { buyError, buyErrorEnum, sellError, sellErrorEnum }, tokenErrors { canRenounceOwnershipError, canTransferOwnershipError, decimalsError, tokenNameError, tokenSymbolError, totalSupplyError }, transferErrors { tokenContractApprovalError, tokenTransferredToContractError, userApprovalError } }, id, liquidity { addLiquiditySuccess, liquiditySetByPreLiquidityOpenTradingCall, lpTotalSupply, pairAddress, postLiquidityEnableTradingCall, postLiquidityEnableTradingSuccess, preLiquidityEnableTradingCall, preLiquidityEnableTradingSuccess, preLiquidityEnableTradingSupportsTransfer }, networkId, owner { ownerAddress, ownerEthBalance, ownerTokenBalance }, sortKey, status, swap { buyGasUsed, buySuccess, buyTax, maxBuyAmount, maxSellAmount, sellGasUsed, sellSuccess, sellTax }, timestamp, token { canRenounceOwnership, canTransferOwnership, contractAddress, decimals, isOwnerRenounced, tokenName, tokenSymbol, totalSupply }, transfer { tokenContractApprovalSuccess, tokenTransferredToContractSuccess, userApprovalSuccess }, uuid, uuidHashKey
  }
}`,
      vars,
      sink,
    );
  onNftEventsCreated = async (
    vars: OnNftEventsCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnNftEventsCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnNftEventsCreated($address: String, $networkId: Int) {
  onNftEventsCreated (address: $address, networkId: $networkId) {
    address, events { aggregatorAddress, baseTokenAddress, baseTokenPrice, blockNumber, contractAddress, eventType, exchangeAddress, fillSource, id, individualBaseTokenPrice, individualNetworkBaseTokenPrice, individualPrice, individualPriceNetworkBaseToken, individualPriceUsd, individualTokenPrice, individualTradePrice, logIndex, maker, networkBaseTokenPrice, networkId, numberOfTokens, orderDirection, paymentTokenAddress, poolAddress, priceError, sortKey, taker, timestamp, tokenId, tokenPrice, totalPrice, totalPriceNetworkBaseToken, totalPriceUsd, totalTradePrice, transactionHash, transactionIndex }, id, networkId
  }
}`,
      vars,
      sink,
    );
  onEventsCreated = async (
    vars: OnEventsCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnEventsCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnEventsCreated($address: String, $id: String, $quoteToken: QuoteToken) {
  onEventsCreated (address: $address, id: $id, quoteToken: $quoteToken) {
    address, events { address, baseTokenPrice, blockHash, blockNumber, eventDisplayType, eventType, id, labels { sandwich { label, sandwichType, token0DrainedAmount, token1DrainedAmount }, washtrade { label } }, liquidityToken, logIndex, maker, networkId, quoteToken, timestamp, token0PoolValueUsd, token0SwapValueUsd, token0ValueBase, token1PoolValueUsd, token1SwapValueUsd, token1ValueBase, transactionHash, transactionIndex }, id, networkId, quoteToken
  }
}`,
      vars,
      sink,
    );
  onNftPoolEventsCreated = async (
    vars: OnNftPoolEventsCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnNftPoolEventsCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnNftPoolEventsCreated($collectionAddress: String, $exchangeAddress: String, $networkId: Int, $poolAddress: String) {
  onNftPoolEventsCreated (collectionAddress: $collectionAddress, exchangeAddress: $exchangeAddress, networkId: $networkId, poolAddress: $poolAddress) {
    collectionAddress, events { blockHash, blockNumber, collectionAddress, collectionId, eventType, exchangeAddress, id, logIndex, maker, networkId, poolAddress, poolType, timestamp, tokenAddress, transactionHash, transactionIndex }, exchangeAddress, id, networkId, poolAddress
  }
}`,
      vars,
      sink,
    );
  onEventLabelCreated = async (
    vars: OnEventLabelCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnEventLabelCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnEventLabelCreated($id: String) {
  onEventLabelCreated (id: $id) {
    id, label, logIndex, networkId, timestamp, transactionHash, transactionIndex
  }
}`,
      vars,
      sink,
    );
  onTokenLifecycleEventsCreated = async (
    vars: OnTokenLifecycleEventsCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnTokenLifecycleEventsCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnTokenLifecycleEventsCreated($address: String, $networkId: Int) {
  onTokenLifecycleEventsCreated (address: $address, networkId: $networkId) {
    events { blockHash, blockNumber, eventType, id, logIndex, maker, networkId, timestamp, tokenAddress, transactionHash, transactionIndex }, id
  }
}`,
      vars,
      sink,
    );
  onNftAssetsCreated = async (
    vars: OnNftAssetsCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnNftAssetsCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnNftAssetsCreated($address: String, $networkId: Int, $tokenId: String) {
  onNftAssetsCreated (address: $address, networkId: $networkId, tokenId: $tokenId) {
    address, attributes { class, css, displayType, maxValue, name, value, valueType }, description, id, media { image, processed, thumbLg, thumbSm }, name, networkId, originalImage, quantity, rawAssetData { animationUrl, externalUrl, imageData, imageUrl }, tokenId, uri
  }
}`,
      vars,
      sink,
    );
  onPriceUpdated = async (
    vars: OnPriceUpdatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnPriceUpdatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnPriceUpdated($address: String, $networkId: Int) {
  onPriceUpdated (address: $address, networkId: $networkId) {
    address, confidence, networkId, priceUsd, timestamp
  }
}`,
      vars,
      sink,
    );
  onPairMetadataUpdated = async (
    vars: OnPairMetadataUpdatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnPairMetadataUpdatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnPairMetadataUpdated($id: String, $quoteToken: QuoteToken, $statsType: TokenPairStatisticsType) {
  onPairMetadataUpdated (id: $id, quoteToken: $quoteToken, statsType: $statsType) {
    exchangeId, fee, highPrice1, highPrice1w, highPrice4, highPrice12, highPrice24, id, liquidity, liquidityToken, lowPrice1, lowPrice1w, lowPrice4, lowPrice12, lowPrice24, networkId, nonLiquidityToken, pairAddress, price, priceChange1, priceChange1w, priceChange4, priceChange5m, priceChange12, priceChange24, quoteToken, statsType, tickSpacing, token0 { address, decimals, labels { createdAt, subType, type }, name, networkId, pooled, price, symbol }, token1 { address, decimals, labels { createdAt, subType, type }, name, networkId, pooled, price, symbol }, volume1, volume1w, volume4, volume12, volume24
  }
}`,
      vars,
      sink,
    );
  onLatestPairUpdated = async (
    vars: OnLatestPairUpdatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnLatestPairUpdatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnLatestPairUpdated($id: String, $networkId: Int) {
  onLatestPairUpdated (id: $id, networkId: $networkId) {
    address, exchangeHash, id, initialPriceUsd, liquidAt, liquidity, liquidityToken, networkId, newToken, nonLiquidityToken, oldToken, priceChange, priceUsd, token0 { address, currentPoolAmount, decimals, id, initialPoolAmount, name, networkId, pairId, poolVariation, symbol }, token1 { address, currentPoolAmount, decimals, id, initialPoolAmount, name, networkId, pairId, poolVariation, symbol }, transactionHash
  }
}`,
      vars,
      sink,
    );
  onTokenEventsCreated = async (
    vars: OnTokenEventsCreatedSubscriptionVariables,
    sink: Sink<ExecutionResult<OnTokenEventsCreatedSubscription>>,
  ) =>
    this.sdk.subscribe(
      `subscription OnTokenEventsCreated($input: OnTokenEventsCreatedInput!) {
  onTokenEventsCreated (input: $input) {
    events { address, baseTokenPrice, blockHash, blockNumber, eventDisplayType, eventType, id, labels { sandwich { label, sandwichType, token0DrainedAmount, token1DrainedAmount }, washtrade { label } }, liquidityToken, logIndex, maker, networkId, quoteToken, timestamp, token0PoolValueUsd, token0SwapValueUsd, token0ValueBase, token1PoolValueUsd, token1SwapValueUsd, token1ValueBase, transactionHash, transactionIndex }, id
  }
}`,
      vars,
      sink,
    );
}
